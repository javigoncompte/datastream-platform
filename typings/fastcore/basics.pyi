"""
This type stub file was generated by pyright.
"""

from .imports import *
from datetime import date

"""Basic functionality used in the fastai library"""
__all__ = ['defaults', 'null', 'num_methods', 'rnum_methods', 'inum_methods', 'arg0', 'arg1', 'arg2', 'arg3', 'arg4', 'Self', 'type_map', 'ifnone', 'maybe_attr', 'basic_repr', 'BasicRepr', 'is_array', 'listify', 'tuplify', 'true', 'NullType', 'tonull', 'get_class', 'mk_class', 'wrap_class', 'ignore_exceptions', 'exec_local', 'risinstance', 'ver2tuple', 'Inf', 'in_', 'ret_true', 'ret_false', 'stop', 'gen', 'chunked', 'otherwise', 'custom_dir', 'AttrDict', 'AttrDictDefault', 'NS', 'get_annotations_ex', 'eval_type', 'type_hints', 'annotations', 'anno_ret', 'signature_ex', 'union2tuple', 'argnames', 'with_cast', 'store_attr', 'attrdict', 'properties', 'camel2words', 'camel2snake', 'snake2camel', 'class2attr', 'getcallable', 'getattrs', 'hasattrs', 'setattrs', 'try_attrs', 'GetAttrBase', 'GetAttr', 'delegate_attr', 'ShowPrint', 'Int', 'Str', 'Float', 'partition', 'partition_dict', 'flatten', 'concat', 'strcat', 'detuplify', 'replicate', 'setify', 'merge', 'range_of', 'groupby', 'last_index', 'filter_dict', 'filter_keys', 'filter_values', 'cycle', 'zip_cycle', 'sorted_ex', 'not_', 'argwhere', 'filter_ex', 'renumerate', 'first', 'last', 'only', 'nested_attr', 'nested_setdefault', 'nested_callable', 'nested_idx', 'set_nested_idx', 'val2idx', 'uniqueify', 'loop_first_last', 'loop_first', 'loop_last', 'first_match', 'last_match', 'fastuple', 'bind', 'mapt', 'map_ex', 'compose', 'maps', 'partialler', 'instantiate', 'using_attr', 'copy_func', 'patch_to', 'patch', 'patch_property', 'compile_re', 'ImportEnum', 'StrEnum', 'str_enum', 'ValEnum', 'Stateful', 'NotStr', 'PrettyString', 'even_mults', 'num_cpus', 'add_props', 'str2bool', 'str2int', 'str2float', 'str2list', 'str2date', 'to_bool', 'to_int', 'to_float', 'to_list', 'to_date', 'typed', 'exec_new', 'exec_import', 'lt', 'gt', 'le', 'ge', 'eq', 'ne', 'add', 'sub', 'mul', 'truediv', 'is_', 'is_not', 'mod']
defaults = ...
def ifnone(a, b):
    "`b` if `a` is None else `a`"
    ...

def maybe_attr(o, attr): # -> Any:
    "`getattr(o,attr,o)`"
    ...

def basic_repr(flds=...): # -> Callable[..., str]:
    "Minimal `__repr__`"
    ...

class BasicRepr:
    "Base class for objects needing a basic `__repr__`"
    __repr__ = ...


def is_array(x): # -> bool:
    "`True` if `x` supports `__array__` or `iloc`"
    ...

def listify(o=..., *rest, use_list=..., match=...): # -> list[Any | None] | list[Any] | list[str | bytes | tuple[Any | None, *tuple[Any, ...]] | Any] | list[tuple[Any | None, *tuple[Any, ...]] | Any]:
    "Convert `o` to a `list`"
    ...

def tuplify(o, use_list=..., match=...): # -> tuple[tuple[Any | None, *tuple[Any, ...]] | Any, ...]:
    "Make `o` a tuple"
    ...

def true(x): # -> bool:
    "Test whether `x` is truthy; collections with >0 elements are considered `True`"
    ...

class NullType:
    "An object that is `False` and can be called, chained, and indexed"
    def __getattr__(self, *args): # -> NullType:
        ...
    
    def __call__(self, *args, **kwargs): # -> NullType:
        ...
    
    def __getitem__(self, *args): # -> NullType:
        ...
    
    def __bool__(self): # -> Literal[False]:
        ...
    


null = ...
def tonull(x): # -> NullType:
    "Convert `None` to `null`"
    ...

def get_class(nm, *fld_names, sup=..., doc=..., funcs=..., anno=..., **flds): # -> Any:
    "Dynamically create a class, optionally inheriting from `sup`, containing `fld_names`"
    ...

def mk_class(nm, *fld_names, sup=..., doc=..., funcs=..., mod=..., anno=..., **flds): # -> None:
    "Create a class using `get_class` and add to the caller's module"
    ...

def wrap_class(nm, *fld_names, sup=..., doc=..., funcs=..., **flds): # -> Callable[..., Any]:
    "Decorator: makes function a method of a new class `nm` passing parameters to `mk_class`"
    ...

class ignore_exceptions:
    "Context manager to ignore exceptions"
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, *args): # -> Literal[True]:
        ...
    


def exec_local(code, var_name):
    "Call `exec` on `code` and return the var `var_name`"
    ...

def risinstance(types, obj=...): # -> partial[bool] | bool:
    "Curried `isinstance` but with args reversed"
    ...

def ver2tuple(v: str) -> tuple:
    ...

class _InfMeta(type):
    @property
    def count(self): # -> count[int]:
        ...
    
    @property
    def zeros(self): # -> cycle[int]:
        ...
    
    @property
    def ones(self): # -> cycle[int]:
        ...
    
    @property
    def nones(self): # -> cycle[None]:
        ...
    


class Inf(metaclass=_InfMeta):
    "Infinite lists"
    ...


_dumobj = ...
def in_(x, a): # -> bool:
    "`True` if `x in a`"
    ...

_all_ = ...
def ret_true(*args, **kwargs): # -> Literal[True]:
    "Predicate: always `True`"
    ...

def ret_false(*args, **kwargs): # -> Literal[False]:
    "Predicate: always `False`"
    ...

def stop(e=...):
    "Raises exception `e` (by default `StopIteration`)"
    ...

def gen(func, seq, cond=...): # -> takewhile[Any]:
    "Like `(func(o) for o in seq if cond(func(o)))` but handles `StopIteration`"
    ...

def chunked(it, chunk_sz=..., drop_last=..., n_chunks=...): # -> Generator[list[object], Any, None]:
    "Return batches from iterator `it` of size `chunk_sz` (or return `n_chunks` total)"
    ...

def otherwise(x, tst, y):
    "`y if tst(x) else x`"
    ...

def custom_dir(c, add):
    "Implement custom `__dir__`, adding `add` to `cls`"
    ...

class AttrDict(dict):
    "`dict` subclass that also provides access to keys as attrs"
    def __getattr__(self, k):
        ...
    
    def __setattr__(self, k, v): # -> None:
        ...
    
    def __dir__(self):
        ...
    
    def copy(self): # -> AttrDict:
        ...
    


class AttrDictDefault(AttrDict):
    "`AttrDict` subclass that returns `None` for missing attrs"
    def __init__(self, *args, default_=..., **kwargs) -> None:
        ...
    
    def __getattr__(self, k): # -> None:
        ...
    


class NS(SimpleNamespace):
    "`SimpleNamespace` subclass that also adds `iter` and `dict` support"
    def __iter__(self): # -> Iterator[str]:
        ...
    
    def __getitem__(self, x): # -> Any:
        ...
    
    def __setitem__(self, x, y): # -> None:
        ...
    


def get_annotations_ex(obj, *, globals=..., locals=...):
    "Backport of py3.10 `get_annotations` that returns globals/locals"
    ...

def eval_type(t, glb, loc): # -> UnionType | Any | list[Any] | tuple[Any, ...]:
    "`eval` a type or collection of types, if needed, for annotations in py3.10+"
    ...

def type_hints(f): # -> dict[Any, Any] | dict[Any, type[None] | UnionType | Any | list[Any] | tuple[Any, ...]]:
    "Like `typing.get_type_hints` but returns `{}` if not allowed type"
    ...

def annotations(o): # -> dict[Any, Any] | dict[Any, type[None] | UnionType | Any | list[Any] | tuple[Any, ...]]:
    "Annotations for `o`, or `type(o)`"
    ...

def anno_ret(func): # -> type[None] | UnionType | Any | list[Any] | tuple[Any, ...] | None:
    "Get the return annotation of `func`"
    ...

def signature_ex(obj, eval_str: bool = ...): # -> Signature | None:
    "Backport of `inspect.signature(..., eval_str=True` to <py310"
    ...

def union2tuple(t): # -> tuple[Any, ...]:
    ...

def argnames(f, frame=...): # -> Any:
    "Names of arguments to function or frame `f`"
    ...

def with_cast(f): # -> _Wrapped[..., Any, ..., Any | None]:
    "Decorator which uses any parameter annotations as preprocessing functions"
    ...

def store_attr(names=..., self=..., but=..., cast=..., store_args=..., **attrs): # -> None:
    "Store params named in comma-separated `names` from calling context into attrs in `self`"
    ...

def attrdict(o, *ks, default=...): # -> dict[Any, Any | None]:
    "Dict from each `k` in `ks` to `getattr(o,k)`"
    ...

def properties(cls, *ps): # -> None:
    "Change attrs in `cls` with names in `ps` to properties"
    ...

_c2w_re = ...
_camel_re1 = ...
_camel_re2 = ...
def camel2words(s, space=...): # -> str:
    "Convert CamelCase to 'spaced words'"
    ...

def camel2snake(name): # -> str:
    "Convert CamelCase to snake_case"
    ...

def snake2camel(s): # -> str:
    "Convert snake_case to CamelCase"
    ...

def class2attr(self, cls_name): # -> str:
    "Return the snake-cased name of the class; strip ending `cls_name` if it exists."
    ...

def getcallable(o, attr): # -> Any | Callable[..., Any | None]:
    "Calls `getattr` with a default of `noop`"
    ...

def getattrs(o, *attrs, default=...): # -> list[Any | None]:
    "List of all `attrs` in `o`"
    ...

def hasattrs(o, attrs): # -> bool:
    "Test whether `o` contains all `attrs`"
    ...

def setattrs(dest, flds, src): # -> None:
    ...

def try_attrs(obj, *attrs): # -> Any:
    "Return first attr that exists in `obj`"
    ...

class GetAttrBase:
    "Basic delegation of `__getattr__` and `__dir__`"
    _attr = ...
    def __getattr__(self, k):
        ...
    
    def __dir__(self):
        ...
    


class GetAttr:
    "Inherit from this to have all attr accesses in `self._xtra` passed down to `self.default`"
    _default = ...
    def __getattr__(self, k): # -> Any:
        ...
    
    def __dir__(self):
        ...
    
    def __setstate__(self, data): # -> None:
        ...
    


def delegate_attr(self, k, to): # -> Any:
    "Use in `__getattr__` to delegate to attr `to` without inheriting from `GetAttr`"
    ...

class ShowPrint:
    "Base class that prints for `show`"
    def show(self, *args, **kwargs): # -> None:
        ...
    


class Int(int, ShowPrint):
    "An extensible `int`"
    ...


class Str(str, ShowPrint):
    "An extensible `str`"
    ...


class Float(float, ShowPrint):
    "An extensible `float`"
    ...


def partition(coll, f): # -> tuple[tuple[Any, ...] | list[Any], tuple[Any, ...] | list[Any]]:
    "Partition a collection by a predicate"
    ...

def partition_dict(d, f): # -> tuple[dict[Any, Any], dict[Any, Any]]:
    "Partition a dict by a predicate that takes key/value params"
    ...

def flatten(o): # -> Generator[str | Any, Any, None]:
    "Concatenate all collections and items as a generator"
    ...

def concat(colls) -> list:
    "Concatenate all collections and items as a list"
    ...

def strcat(its, sep: str = ...) -> str:
    "Concatenate stringified items `its`"
    ...

def detuplify(x): # -> None:
    "If `x` is a tuple with one thing, extract it"
    ...

def replicate(item, match): # -> tuple[Any, ...]:
    "Create tuple of `item` copied `len(match)` times"
    ...

def setify(o): # -> set[Any] | set[tuple[Any | None, *tuple[Any, ...]] | Any]:
    "Turn any list like-object into a set."
    ...

def merge(*ds): # -> dict[Any, Any]:
    "Merge all dictionaries in `ds`"
    ...

def range_of(x): # -> list[int]:
    "All indices of collection `x` (i.e. `list(range(len(x)))`)"
    ...

def groupby(x, key, val=...): # -> dict[Any, Any]:
    "Like `itertools.groupby` but doesn't need to be sorted, and isn't lazy, plus some extensions"
    ...

def last_index(x, o): # -> int:
    "Finds the last index of occurence of `x` in `o` (returns -1 if no occurence)"
    ...

def filter_dict(d, func): # -> dict[Any, Any]:
    "Filter a `dict` using `func`, applied to keys and values"
    ...

def filter_keys(d, func): # -> dict[Any, Any]:
    "Filter a `dict` using `func`, applied to keys"
    ...

def filter_values(d, func): # -> dict[Any, Any]:
    "Filter a `dict` using `func`, applied to values"
    ...

def cycle(o): # -> cycle[tuple[Any | None, *tuple[Any, ...]] | Any] | cycle[None]:
    "Like `itertools.cycle` except creates list of `None`s if `o` is empty"
    ...

def zip_cycle(x, *args): # -> zip[tuple[Any, ...]]:
    "Like `itertools.zip_longest` but `cycle`s through elements of all but first argument"
    ...

def sorted_ex(iterable, key=..., reverse=..., cmp=..., **kwargs):
    "Like `sorted`, but if key is str use `attrgetter`; if int use `itemgetter`; use `cmp` comparator function or `key` with `kwargs`"
    ...

def not_(f): # -> Callable[..., bool]:
    "Create new function that negates result of `f`"
    ...

def argwhere(iterable, f, negate=..., **kwargs): # -> list[int]:
    "Like `filter_ex`, but return indices for matching items"
    ...

def filter_ex(iterable, f=..., negate=..., gen=..., **kwargs): # -> filter[Any] | list[Any]:
    "Like `filter`, but passing `kwargs` to `f`, defaulting `f` to `noop`, and adding `negate` and `gen`"
    ...

def range_of(a, b=..., step=...): # -> list[int]:
    "All indices of collection `a`, if `a` is a collection, otherwise `range`"
    ...

def renumerate(iterable, start=...): # -> Generator[tuple[Any, int], None, None]:
    "Same as `enumerate`, but returns index as 2nd element instead of 1st"
    ...

def first(x, f=..., negate=..., **kwargs): # -> None:
    "First element of `x`, optionally filtered by `f`, or None if missing"
    ...

def last(x, f=..., negate=..., **kwargs): # -> None:
    "Last element of `x`, optionally filtered by `f`, or None if missing"
    ...

def only(o):
    "Return the only item of `o`, raise if `o` doesn't have exactly one item"
    ...

def nested_attr(o, attr, default=...): # -> Any | None:
    "Same as `getattr`, but if `attr` includes a `.`, then looks inside nested objects"
    ...

def nested_setdefault(o, attr, default):
    "Same as `setdefault`, but if `attr` includes a `.`, then looks inside nested objects"
    ...

def nested_callable(o, attr): # -> Callable[..., Any | None] | Any:
    "Same as `nested_attr` but if not found will return `noop`"
    ...

def nested_idx(coll, *idxs): # -> Any | None:
    "Index into nested collections, dicts, etc, with `idxs`"
    ...

def set_nested_idx(coll, value, *idxs): # -> None:
    "Set value indexed like `nested_idx"
    ...

def val2idx(x): # -> dict[Any, int]:
    "Dict from value to index"
    ...

def uniqueify(x, sort=..., bidir=..., start=...): # -> tuple[list[Any | None] | Any | list[Any] | list[str | bytes | tuple[Any | None, *tuple[Any, ...]] | Any] | list[tuple[Any | None, *tuple[Any, ...]] | Any], dict[tuple[Any | None, *tuple[Any, ...]] | Any, int]] | list[Any | None] | list[Any] | list[str | bytes | tuple[Any | None, *tuple[Any, ...]] | Any] | list[tuple[Any | None, *tuple[Any, ...]] | Any]:
    "Unique elements in `x`, optional `sort`, optional return reverse correspondence, optional prepend with elements."
    ...

def loop_first_last(values): # -> Generator[tuple[bool, Literal[False], Any] | tuple[bool, Literal[True], Any], Any, None]:
    "Iterate and generate a tuple with a flag for first and last value."
    ...

def loop_first(values): # -> Generator[tuple[bool, Any], None, None]:
    "Iterate and generate a tuple with a flag for first value."
    ...

def loop_last(values): # -> Generator[tuple[bool, Any], None, None]:
    "Iterate and generate a tuple with a flag for last value."
    ...

def first_match(lst, f, default=...): # -> int | None:
    "First element of `lst` matching predicate `f`, or `default` if none"
    ...

def last_match(lst, f, default=...): # -> int | None:
    "Last element of `lst` matching predicate `f`, or `default` if none"
    ...

num_methods = ...
rnum_methods = ...
inum_methods = ...
class fastuple(tuple):
    "A `tuple` with elementwise ops and more friendly __init__ behavior"
    def __new__(cls, x=..., *rest): # -> Self:
        ...
    
    def mul(self, *args): # -> fastuple:
        "`*` is already defined in `tuple` for replicating, so use `mul` instead"
        ...
    
    def add(self, *args): # -> fastuple:
        "`+` is already defined in `tuple` for concat, so use `add` instead"
        ...
    


class _Arg:
    def __init__(self, i) -> None:
        ...
    


arg0 = ...
arg1 = ...
arg2 = ...
arg3 = ...
arg4 = ...
class bind:
    "Same as `partial`, except you can use `arg0` `arg1` etc param placeholders"
    def __init__(self, func, *pargs, **pkwargs) -> None:
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    


def mapt(func, *iterables): # -> tuple[Any, ...]:
    "Tuplified `map`"
    ...

def map_ex(iterable, f, *args, gen=..., **kwargs): # -> map[str] | list[str]:
    "Like `map`, but use `bind`, and supports `str` and indexing"
    ...

def compose(*funcs, order=...): # -> Callable[..., Any | None] | str | bytes | tuple[Any | None, *tuple[Any, ...]] | Callable[..., Any] | None:
    "Create a function that composes all functions in `funcs`, passing along remaining `*args` and `**kwargs` to all"
    ...

def maps(*args, retain=...): # -> map[Any]:
    "Like `map`, except funcs are composed first"
    ...

def partialler(f, *args, order=..., **kwargs): # -> partial[Any]:
    "Like `functools.partial` but also copies over docstring"
    ...

def instantiate(t): # -> Any:
    "Instantiate `t` if it's a type, otherwise do nothing"
    ...

def using_attr(f, attr): # -> partial[Any]:
    "Construct a function which applies `f` to the argument's attribute `attr`"
    ...

class _Self:
    "An alternative to `lambda` for calling methods on passed object."
    def __init__(self) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __call__(self, *args, **kwargs): # -> object | Any | Callable[..., object] | Self:
        ...
    
    def __getattr__(self, k): # -> Self:
        ...
    


class _SelfCls:
    def __getattr__(self, k): # -> Any:
        ...
    
    def __getitem__(self, i): # -> Any:
        ...
    
    def __call__(self, *args, **kwargs): # -> Any:
        ...
    


Self = ...
_all_ = ...
def copy_func(f): # -> FunctionType:
    "Copy a non-builtin function (NB `copy.copy` does not work for this)"
    ...

class _clsmethod:
    def __init__(self, f) -> None:
        ...
    
    def __get__(self, _, f_cls): # -> MethodType:
        ...
    


def patch_to(cls, as_prop=..., cls_method=..., set_prop=...): # -> Callable[..., Any | None]:
    "Decorator: add `f` to `cls`"
    ...

def patch(f=..., *, as_prop=..., cls_method=..., set_prop=...): # -> partial[Any] | Any | None:
    "Decorator: add `f` to the first parameter's class (based on f's type annotations)"
    ...

def patch_property(f): # -> Any | None:
    "Deprecated; use `patch(as_prop=True)` instead"
    ...

def compile_re(pat): # -> Pattern[Any] | None:
    "Compile `pat` if it's not None"
    ...

class ImportEnum(enum.Enum):
    "An `Enum` that can have its values imported"
    @classmethod
    def imports(cls): # -> None:
        ...
    


class StrEnum(str, ImportEnum):
    "An `ImportEnum` that behaves like a `str`"
    def __str__(self) -> str:
        ...
    


def str_enum(name, *vals): # -> StrEnum:
    "Simplified creation of `StrEnum` types"
    ...

class ValEnum(str, ImportEnum):
    "An `ImportEnum` that stringifies using values"
    def __str__(self) -> str:
        ...
    


class Stateful:
    "A base class/mixin for objects that should not serialize all their state"
    _stateattrs = ...
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, state): # -> None:
        ...
    


class NotStr(GetAttr):
    "Behaves like a `str`, but isn't an instance of one"
    _default = ...
    def __init__(self, s) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __add__(self, b): # -> NotStr:
        ...
    
    def __mul__(self, b): # -> NotStr:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __eq__(self, b) -> bool:
        ...
    
    def __lt__(self, b) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __contains__(self, b): # -> bool:
        ...
    
    def __iter__(self):
        ...
    


class PrettyString(str):
    "Little hack to get strings to show properly in Jupyter."
    def __repr__(self): # -> Self:
        ...
    


def even_mults(start, stop, n): # -> list[Any]:
    "Build log-stepped array from `start` to `stop` in `n` steps."
    ...

def num_cpus(): # -> int | None:
    "Get number of cpus"
    ...

def add_props(f, g=..., n=...): # -> Generator[property, None, None]:
    "Create properties passing each of `range(n)` to f"
    ...

def str2bool(s): # -> bool:
    "Case-insensitive convert string `s` too a bool (`y`,`yes`,`t`,`true`,`on`,`1`->`True`)"
    ...

def str2int(s) -> int:
    "Convert `s` to an `int`"
    ...

def str2float(s: str): # -> float:
    "Convert `s` to a float"
    ...

def str2list(s: str): # -> list[Any] | Any:
    "Convert `s` to a list"
    ...

def str2date(s: str) -> date:
    "`date.fromisoformat` with empty string handling"
    ...

def to_bool(arg): # -> bool:
    ...

def to_int(arg): # -> int:
    ...

def to_float(arg): # -> float:
    ...

def to_list(arg): # -> list[Any] | Any | list[Any | None] | list[str | bytes | tuple[Any | None, *tuple[Any, ...]] | Any] | list[tuple[Any | None, *tuple[Any, ...]] | Any]:
    ...

def to_date(arg): # -> date:
    ...

type_map = ...
def typed(_func=..., *, cast=...): # -> Callable[..., _Wrapped[..., Any, ..., Any]] | _Wrapped[..., Any, ..., Any]:
    "Decorator to check param and return types at runtime, with optional casting"
    ...

def exec_new(code): # -> dict[str, str | None]:
    "Execute `code` in a new environment and return it"
    ...

def exec_import(mod, sym): # -> dict[str, str | None]:
    "Import `sym` from `mod` in a new environment"
    ...

