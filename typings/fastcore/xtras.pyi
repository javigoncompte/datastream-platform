"""
This type stub file was generated by pyright.
"""

import string
from .imports import *
from .foundation import *
from .basics import *
from enum import Enum
from contextlib import contextmanager
from datetime import datetime
from dataclasses import dataclass

"""Utility functions used in the fastai library"""
__all__ = ['spark_chars', 'UNSET', 'walk', 'globtastic', 'maybe_open', 'mkdir', 'image_size', 'bunzip', 'loads', 'loads_multi', 'dumps', 'untar_dir', 'repo_details', 'run', 'open_file', 'save_pickle', 'load_pickle', 'parse_env', 'expand_wildcards', 'dict2obj', 'obj2dict', 'repr_dict', 'is_listy', 'mapped', 'IterLen', 'ReindexCollection', 'exec_eval', 'get_source_link', 'truncstr', 'sparkline', 'modify_exception', 'round_multiple', 'set_num_threads', 'join_path_file', 'autostart', 'EventTimer', 'stringfmt_names', 'PartialFormatter', 'partial_format', 'utc2local', 'local2utc', 'trace', 'modified_env', 'ContextManagers', 'shufflish', 'console_help', 'hl_md', 'type2str', 'dataclass_src', 'Unset', 'nullable_dc', 'make_nullable', 'flexiclass', 'asdict', 'is_typeddict', 'is_namedtuple', 'flexicache', 'time_policy', 'mtime_policy', 'timed_cache']
def walk(path: Path | str, symlinks: bool = ..., keep_file: callable = ..., keep_folder: callable = ..., skip_folder: callable = ..., func: callable = ..., ret_folders: bool = ...): # -> Generator[Any, Any, None]:
    "Generator version of `os.walk`, using functions to filter files and folders"
    ...

def globtastic(path: Path | str, recursive: bool = ..., symlinks: bool = ..., file_glob: str = ..., file_re: str = ..., folder_re: str = ..., skip_file_glob: str = ..., skip_file_re: str = ..., skip_folder_re: str = ..., func: callable = ..., ret_folders: bool = ...) -> L:
    "A more powerful `glob`, including regex matches, symlink handling, and skip parameters"
    ...

@contextmanager
def maybe_open(f, mode=..., **kwargs): # -> Generator[IO[Any] | Any, Any, None]:
    "Context manager: open `f` if it is a path (and close on exit)"
    ...

def mkdir(path, exist_ok=..., parents=..., overwrite=..., **kwargs): # -> Path:
    "Creates and returns a directory defined by `path`, optionally removing previous existing directory if `overwrite` is `True`"
    ...

def image_size(fn): # -> tuple[Any, Any]:
    "Tuple of (w,h) for png, gif, or jpg; `None` otherwise"
    ...

def bunzip(fn): # -> None:
    "bunzip `fn`, raising exception if output already exists"
    ...

def loads(s, **kw): # -> dict[Any, Any] | Any:
    "Same as `json.loads`, but handles `None`"
    ...

def loads_multi(s: str): # -> Generator[Any, Any, None]:
    "Generator of >=0 decoded json dicts, possibly with non-json ignored text at start and end"
    ...

def dumps(obj, **kw): # -> str:
    "Same as `json.dumps`, but uses `ujson` if available"
    ...

def untar_dir(fname, dest, rename=..., overwrite=...): # -> Path:
    "untar `file` into `dest`, creating a directory if the root contains more than one item"
    ...

def repo_details(url):
    "Tuple of `owner,name` from ssh or https git repo `url`"
    ...

def run(cmd, *rest, same_in_win=..., ignore_ex=..., as_bytes=..., stderr=...): # -> tuple[int, str | bytes] | str | bytes:
    "Pass `cmd` (splitting with `shlex` if string) to `subprocess.run`; return `stdout`; raise `IOError` if fails"
    ...

def open_file(fn, mode=..., **kwargs): # -> IOBase | BZ2File | GzipFile | ZipFile | IO[Any]:
    "Open a file, with optional compression if gz or bz2 suffix"
    ...

def save_pickle(fn, o): # -> None:
    "Save a pickle file, to a file name or opened file"
    ...

def load_pickle(fn): # -> Any:
    "Load a pickle file from a file name or opened file"
    ...

def parse_env(s: str = ..., fn: Union[str, Path] = ...) -> dict:
    "Parse a shell-style environment string or file"
    ...

def expand_wildcards(code): # -> str:
    "Expand all wildcard imports in the given code string."
    ...

def dict2obj(d, list_func=..., dict_func=...): # -> L | AttrDict:
    "Convert (possibly nested) dicts (or lists of dicts) to `AttrDict`"
    ...

def obj2dict(d): # -> list[Any] | dict[str, list[Any] | Any | dict[str, Any]]:
    "Convert (possibly nested) AttrDicts (or lists of AttrDicts) to `dict`"
    ...

def repr_dict(d): # -> LiteralString | str:
    "Print nested dicts and lists, such as returned by `dict2obj`"
    ...

def is_listy(x): # -> bool:
    "`isinstance(x, (tuple,list,L,slice,Generator))`"
    ...

def mapped(f, it): # -> L:
    "map `f` over `it`, unless it's not listy, in which case return `f(it)`"
    ...

@patch
def readlines(self: Path, hint=..., encoding=...): # -> list[str]:
    "Read the content of `self`"
    ...

@patch
def read_json(self: Path, encoding=..., errors=...): # -> dict[Any, Any] | Any:
    "Same as `read_text` followed by `loads`"
    ...

@patch
def mk_write(self: Path, data, encoding=..., errors=..., mode=...): # -> None:
    "Make all parent dirs of `self`, and write `data`"
    ...

@patch
def relpath(self: Path, start=...): # -> Path:
    "Same as `os.path.relpath`, but returns a `Path`, and resolves symlinks"
    ...

@patch
def ls(self: Path, n_max=..., file_type=..., file_exts=...): # -> L:
    "Contents of path as a list"
    ...

@patch
def __repr__(self: Path): # -> str:
    ...

@patch
def delete(self: Path): # -> None:
    "Delete a file, symlink, or directory tree"
    ...

class IterLen:
    "Base class to add iteration to anything supporting `__len__` and `__getitem__`"
    def __iter__(self): # -> Generator[Any, None, None]:
        ...
    


@docs
class ReindexCollection(GetAttr, IterLen):
    "Reindexes collection `coll` with indices `idxs` and optional LRU cache of size `cache`"
    _default = ...
    def __init__(self, coll, idxs=..., cache=..., tfm=...) -> None:
        ...
    
    def __getitem__(self, i):
        ...
    
    def __len__(self): # -> int:
        ...
    
    def reindex(self, idxs): # -> None:
        ...
    
    def shuffle(self): # -> None:
        ...
    
    def cache_clear(self): # -> None:
        ...
    
    def __getstate__(self): # -> dict[str, Any]:
        ...
    
    def __setstate__(self, s): # -> None:
        ...
    
    _docs = ...


def exec_eval(code, g=..., l=...): # -> Any | None:
    "Evaluate `code` in `g` (defaults to `globals()`) and `l` (defaults to `locals()`)"
    ...

def get_source_link(func): # -> str:
    "Return link to `func` in source code"
    ...

def truncstr(s: str, maxlen: int, suf: str = ..., space=...) -> str:
    "Truncate `s` to length `maxlen`, adding suffix `suf` if truncated"
    ...

spark_chars = ...
def sparkline(data, mn=..., mx=..., empty_zero=...): # -> str:
    "Sparkline for `data`, with `None`s (and zero, if `empty_zero`) shown as empty column"
    ...

def modify_exception(e: Exception, msg: str = ..., replace: bool = ...) -> Exception:
    "Modifies `e` with a custom message attached"
    ...

def round_multiple(x, mult, round_down=...): # -> L | Any | list[Any]:
    "Round `x` to nearest multiple of `mult`"
    ...

def set_num_threads(nt): # -> None:
    "Get numpy (and others) to use `nt` threads"
    ...

def join_path_file(file, path, ext=...):
    "Return `path/file` if file is a string or a `Path`, file otherwise"
    ...

def autostart(g): # -> _Wrapped[..., Any, [], Any]:
    "Decorator that automatically starts a generator"
    ...

class EventTimer:
    "An event timer with history of `store` items of time `span`"
    def __init__(self, store=..., span=...) -> None:
        ...
    
    def add(self, n=...): # -> None:
        "Record `n` events"
        ...
    
    @property
    def duration(self): # -> float:
        ...
    
    @property
    def freq(self): # -> float:
        ...
    


_fmt = ...
def stringfmt_names(s: str) -> list:
    "Unique brace-delimited names in `s`"
    ...

class PartialFormatter(string.Formatter):
    "A `string.Formatter` that doesn't error on missing fields, and tracks missing fields and unused args"
    def __init__(self) -> None:
        ...
    
    def get_field(self, nm, args, kwargs): # -> Any | tuple[Any, Any]:
        ...
    
    def check_unused_args(self, used, args, kwargs): # -> None:
        ...
    


def partial_format(s: str, **kwargs): # -> tuple[str, list[Any], dict[Any, Any]]:
    "string format `s`, ignoring missing field errors, returning missing and extra fields"
    ...

def utc2local(dt: datetime) -> datetime:
    "Convert `dt` from UTC to local time"
    ...

def local2utc(dt: datetime) -> datetime:
    "Convert `dt` from local to UTC time"
    ...

def trace(f): # -> Callable[..., Any]:
    "Add `set_trace` to an existing function `f`"
    ...

@contextmanager
def modified_env(*delete, **replace): # -> Generator[None, Any, None]:
    "Context manager temporarily modifying `os.environ` by deleting `delete` and replacing `replace`"
    ...

class ContextManagers(GetAttr):
    "Wrapper for `contextlib.ExitStack` which enters a collection of context managers"
    def __init__(self, mgrs) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, *args, **kwargs): # -> None:
        ...
    


def shufflish(x, pct=...): # -> L:
    "Randomly relocate items of `x` up to `pct` of `len(x)` from their starting location"
    ...

def console_help(libname: str): # -> None:
    "Show help for all console scripts from `libname`"
    ...

def hl_md(s, lang=..., show=...): # -> str | None:
    "Syntax highlight `s` using `lang`."
    ...

def type2str(typ: type) -> str:
    "Stringify `typ`"
    ...

def dataclass_src(cls): # -> str:
    ...

class Unset(Enum):
    _Unset = ...
    def __repr__(self): # -> Literal['UNSET']:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __bool__(self): # -> Literal[False]:
        ...
    


UNSET = ...
def nullable_dc(cls): # -> Callable[[type[_T]], type[_T]]:
    "Like `dataclass`, but default of `UNSET` added to fields without defaults"
    ...

def make_nullable(clas): # -> None:
    ...

def flexiclass(cls) -> dataclass:
    "Convert `cls` into a `dataclass` like `make_nullable`. Converts in place and also returns the result."
    ...

def asdict(o) -> dict:
    "Convert `o` to a `dict`, supporting dataclasses, namedtuples, iterables, and `__dict__` attrs."
    ...

def is_typeddict(cls: type) -> bool:
    "Check if `cls` is a `TypedDict`"
    ...

def is_namedtuple(cls): # -> bool:
    "`True` if `cls` is a namedtuple type"
    ...

def flexicache(*funcs, maxsize=...): # -> Callable[..., _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Any]]:
    "Like `lru_cache`, but customisable with policy `funcs`"
    ...

def time_policy(seconds): # -> Callable[..., float | None]:
    "A `flexicache` policy that expires cached items after `seconds` have passed"
    ...

def mtime_policy(filepath): # -> Callable[..., float | None]:
    "A `flexicache` policy that expires cached items after `filepath` modified-time changes"
    ...

def timed_cache(seconds=..., maxsize=...): # -> Callable[..., _Wrapped[..., Any, ..., CoroutineType[Any, Any, Any]] | _Wrapped[..., Any, ..., Any]]:
    "Like `lru_cache`, but also with time-based eviction"
    ...

