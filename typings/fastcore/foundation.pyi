"""
This type stub file was generated by pyright.
"""

from .imports import *
from .basics import *
from contextlib import contextmanager

"""The `L` class and helpers for it"""
__all__ = ['working_directory', 'add_docs', 'docs', 'coll_repr', 'is_bool', 'mask2idxs', 'cycle', 'zip_cycle', 'is_indexer', 'CollBase', 'L', 'save_config_file', 'read_config_file', 'Config']
@contextmanager
def working_directory(path): # -> Generator[None, Any, None]:
    "Change working directory to `path` and return to previous on exit."
    ...

def add_docs(cls, cls_doc=..., **docs): # -> None:
    "Copy values from `docs` to `cls` docstrings, and confirm all public methods are documented"
    ...

def docs(cls):
    "Decorator version of `add_docs`, using `_docs` dict"
    ...

def coll_repr(c, max_n=...): # -> str:
    "String repr of up to `max_n` items of (possibly lazy) collection `c`"
    ...

def is_bool(x): # -> partial[bool] | bool:
    "Check whether `x` is a bool or None"
    ...

def mask2idxs(mask): # -> slice[object, object, object] | list[Any] | list[int]:
    "Convert bool mask or index list to index `L`"
    ...

def cycle(o): # -> cycle[tuple[Any | None, *tuple[Any, ...]] | Any] | cycle[None]:
    "Like `itertools.cycle` except creates list of `None`s if `o` is empty"
    ...

def zip_cycle(x, *args): # -> zip[tuple[Any, ...]]:
    "Like `itertools.zip_longest` but `cycle`s through elements of all but first argument"
    ...

def is_indexer(idx): # -> bool:
    "Test whether `idx` will index a single item in a list"
    ...

class CollBase:
    "Base class for composing a list of `items`"
    def __init__(self, items) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, k):
        ...
    
    def __setitem__(self, k, v): # -> None:
        ...
    
    def __delitem__(self, i): # -> None:
        ...
    
    def __repr__(self):
        ...
    
    def __iter__(self):
        ...
    


class _L_Meta(type):
    def __call__(cls, x=..., *args, **kwargs): # -> Any:
        ...
    


class L(GetAttr, CollBase, metaclass=_L_Meta):
    "Behaves like a list of `items` but can also index with list of indices or masks"
    _default = ...
    def __init__(self, items=..., *rest, use_list=..., match=...) -> None:
        ...
    
    def __getitem__(self, idx): # -> Any | list[Any] | L:
        ...
    
    def copy(self): # -> Self:
        ...
    
    def __setitem__(self, idx, o): # -> None:
        "Set `idx` (can be list of indices, or mask, or int) items to `o` (which is broadcast if not iterable)"
        ...
    
    def __eq__(self, b) -> bool:
        ...
    
    def sorted(self, key=..., reverse=..., cmp=..., **kwargs): # -> Self:
        ...
    
    def __iter__(self):
        ...
    
    def __contains__(self, b): # -> bool:
        ...
    
    def __reversed__(self): # -> Self:
        ...
    
    def __invert__(self): # -> Self:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __mul__(a, b): # -> Self:
        ...
    
    def __add__(a, b): # -> Self:
        ...
    
    def __radd__(a, b): # -> Self:
        ...
    
    def __addi__(a, b): # -> Self:
        ...
    
    @classmethod
    def split(cls, s, sep=..., maxsplit=...): # -> Self:
        ...
    
    @classmethod
    def splitlines(cls, s, keepends=...): # -> Self:
        ...
    
    @classmethod
    def range(cls, a, b=..., step=...): # -> Self:
        ...
    
    def map(self, f, *args, **kwargs): # -> Self:
        ...
    
    def argwhere(self, f, negate=..., **kwargs): # -> Self:
        ...
    
    def argfirst(self, f, negate=...): # -> None:
        ...
    
    def filter(self, f=..., negate=..., **kwargs): # -> Self:
        ...
    
    def enumerate(self): # -> L:
        ...
    
    def renumerate(self): # -> L:
        ...
    
    def unique(self, sort=..., bidir=..., start=...): # -> L:
        ...
    
    def val2idx(self): # -> dict[Any, int]:
        ...
    
    def cycle(self): # -> cycle[tuple[Any | None, *tuple[Any, ...]] | Any] | cycle[None]:
        ...
    
    def groupby(self, key, val=...): # -> dict[Any, Any]:
        ...
    
    def map_dict(self, f=..., *args, **kwargs): # -> dict[Any, Any]:
        ...
    
    def map_first(self, f=..., g=..., *args, **kwargs): # -> None:
        ...
    
    def itemgot(self, *idxs): # -> Self:
        ...
    
    def attrgot(self, k, default=...): # -> Self:
        ...
    
    def starmap(self, f, *args, **kwargs): # -> Self:
        ...
    
    def zip(self, cycled=...): # -> Self:
        ...
    
    def zipwith(self, *rest, cycled=...): # -> Self:
        ...
    
    def map_zip(self, f, *args, cycled=..., **kwargs): # -> Self:
        ...
    
    def map_zipwith(self, f, *rest, cycled=..., **kwargs): # -> Self:
        ...
    
    def shuffle(self): # -> Self:
        ...
    
    def concat(self): # -> Self:
        ...
    
    def reduce(self, f, initial=...):
        ...
    
    def sum(self): # -> Any:
        ...
    
    def product(self): # -> Any:
        ...
    
    def setattrs(self, attr, val): # -> None:
        ...
    


def save_config_file(file, d, **kwargs): # -> None:
    "Write settings dict to a new config file, or overwrite the existing one."
    ...

def read_config_file(file, **kwargs): # -> SectionProxy:
    ...

class Config:
    "Reading and writing `ConfigParser` ini files"
    def __init__(self, cfg_path, cfg_name, create=..., save=..., extra_files=..., types=..., **cfg_kwargs) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __setitem__(self, k, v): # -> None:
        ...
    
    def __contains__(self, k): # -> bool:
        ...
    
    def save(self): # -> None:
        ...
    
    def __getattr__(self, k): # -> bool | str | Path | None:
        ...
    
    def __getitem__(self, k): # -> bool | str | Path | None:
        ...
    
    def get(self, k, default=...): # -> bool | str | Path | None:
        ...
    
    def path(self, k, default=...): # -> Path | None:
        ...
    
    @classmethod
    def find(cls, cfg_name, cfg_path=..., **kwargs): # -> None:
        "Search `cfg_path` and its parents to find `cfg_name`"
        ...
    


