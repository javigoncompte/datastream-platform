"""
This type stub file was generated by pyright.
"""

from .utils import *
from .parallel import *
from urllib.request import Request
from urllib.error import HTTPError

"""Network, HTTP, and URL functions"""
__all__ = ['url_default_headers', 'ExceptionsHTTP', 'urlquote', 'urlwrap', 'HTTP4xxClientError', 'HTTP5xxServerError', 'urlopener', 'urlopen', 'urlread', 'urljson', 'urlcheck', 'urlclean', 'urlretrieve', 'urldest', 'urlsave', 'urlvalid', 'urlrequest', 'urlsend', 'do_request', 'start_server', 'start_client', 'tobytes', 'http_response', 'recv_once', 'HTTP400BadRequestError', 'HTTP401UnauthorizedError', 'HTTP402PaymentRequiredError', 'HTTP403ForbiddenError', 'HTTP404NotFoundError', 'HTTP405MethodNotAllowedError', 'HTTP406NotAcceptableError', 'HTTP407ProxyAuthRequiredError', 'HTTP408RequestTimeoutError', 'HTTP409ConflictError', 'HTTP410GoneError', 'HTTP411LengthRequiredError', 'HTTP412PreconditionFailedError', 'HTTP413PayloadTooLargeError', 'HTTP414URITooLongError', 'HTTP415UnsupportedMediaTypeError', 'HTTP416RangeNotSatisfiableError', 'HTTP417ExpectationFailedError', 'HTTP418AmAteapotError', 'HTTP421MisdirectedRequestError', 'HTTP422UnprocessableEntityError', 'HTTP423LockedError', 'HTTP424FailedDependencyError', 'HTTP425TooEarlyError', 'HTTP426UpgradeRequiredError', 'HTTP428PreconditionRequiredError', 'HTTP429TooManyRequestsError', 'HTTP431HeaderFieldsTooLargeError', 'HTTP451LegalReasonsError']
url_default_headers = ...
def urlquote(url): # -> Literal[b""]:
    "Update url's path with `urllib.parse.quote`"
    ...

def urlwrap(url, data=..., headers=...): # -> Request:
    "Wrap `url` in a urllib `Request` with `urlquote`"
    ...

ExceptionsHTTP = ...
class HTTP4xxClientError(HTTPError):
    "Base class for client exceptions (code 4xx) from `url*` functions"
    ...


class HTTP5xxServerError(HTTPError):
    "Base class for server exceptions (code 5xx) from `url*` functions"
    ...


def urlopener(): # -> OpenerDirector:
    ...

_httperrors = ...
_all_ = ...
def urlopen(url, data=..., headers=..., timeout=..., **kwargs): # -> _UrlopenRet:
    "Like `urllib.request.urlopen`, but first `urlwrap` the `url`, and encode `data`"
    ...

def urlread(url, data=..., headers=..., decode=..., return_json=..., return_headers=..., timeout=..., **kwargs): # -> tuple[dict[Any, Any] | Any, dict[_UrlopenRet, _UrlopenRet]] | dict[Any, Any] | Any:
    "Retrieve `url`, using `data` dict or `kwargs` to `POST` if present"
    ...

def urljson(url, data=..., headers=..., timeout=...): # -> Any | dict[Any, Any]:
    "Retrieve `url` and decode json"
    ...

def urlcheck(url, headers=..., timeout=...): # -> Any | bool:
    ...

def urlclean(url): # -> str:
    "Remove fragment, params, and querystring from `url` if present"
    ...

def urlretrieve(url, filename=..., reporthook=..., data=..., headers=..., timeout=...): # -> tuple[Any, _UrlopenRet]:
    "Same as `urllib.request.urlretrieve` but also works with `Request` objects"
    ...

def urldest(url, dest=...): # -> Path:
    ...

def urlsave(url, dest=..., reporthook=..., headers=..., timeout=...): # -> Path:
    "Retrieve `url` and save based on its name"
    ...

def urlvalid(x): # -> bool:
    "Test if `x` is a valid URL"
    ...

def urlrequest(url, verb, headers=..., route=..., query=..., data=..., json_data=...): # -> Request:
    "`Request` for `url` with optional route params replaced by `route`, plus `query` string, and post `data`"
    ...

@patch
def summary(self: Request, skip=...) -> dict:
    "Summary containing full_url, headers, method, and data, removing `skip` from headers"
    ...

def urlsend(url, verb, headers=..., decode=..., route=..., query=..., data=..., json_data=..., return_json=..., return_headers=..., debug=..., timeout=...): # -> tuple[dict[Any, Any] | Any, dict[_UrlopenRet, _UrlopenRet]] | dict[Any, Any] | Any:
    "Send request with `urlrequest`, converting result to json if `return_json`"
    ...

def do_request(url, post=..., headers=..., **data): # -> Any | dict[Any, Any]:
    "Call GET or json-encoded POST on `url`, depending on `post`"
    ...

def start_server(port, host=..., dgram=..., reuse_addr=..., n_queue=...): # -> socket:
    "Create a `socket` server on `port`, with optional `host`, of type `dgram`"
    ...

def start_client(port, host=..., dgram=...): # -> socket:
    "Create a `socket` client on `port`, with optional `host`, of type `dgram`"
    ...

def tobytes(s: str) -> bytes:
    "Convert `s` into HTTP-ready bytes format"
    ...

def http_response(body=..., status=..., hdrs=..., **kwargs): # -> bytes:
    "Create an HTTP-ready response, adding `kwargs` to `hdrs`"
    ...

@threaded
def recv_once(host: str = ..., port: int = ...): # -> bytes:
    "Spawn a thread to receive a single HTTP request and store in `d['r']`"
    ...

